1573,1597c1573,1598
<       DEBUG assumptions={}, data={u32 = !ty_1, Not(!ty_1)}
<       prove goal={u32 = ?ty_0, Not(?ty_0)}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<         prove_wc_list goal={u32 = ?ty_0, Not(?ty_0)}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<           prove_wc goal=u32 = ?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<             prove_eq a=u32, b=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<               prove_eq a=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG recursive call to prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }, yielding {}
<                 new judgment="prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                   strip_cycles failed_rules={}
<                     DEBUG cycles={}, non_cycles={}
<                     DEBUG return=({}, HasNonCycle(false))
<                   
<                   DEBUG return=FailedJudgment { judgment: "prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                 
<                 DEBUG rule symmetric failed at step 0 because judgment had no applicable rules: `prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<                 prove_existential_var_eq v=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   equate_variable x=?ty_0, p=u32, env=Env { variables: [?ty_0], bias: Completeness }
<                     DEBUG equated: constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goals={}
<                     prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                       prove goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         prove_wc_list goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                           DEBUG produced Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} } from rule "none" in judgment "prove_wc_list"
<                           DEBUG output={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
<                         
<                         DEBUG result_set={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
---
>       DEBUG assumptions={}, data={Not(!ty_1), u32 = !ty_1}
>       prove goal={Not(?ty_0), u32 = ?ty_0}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>         prove_wc_list goal={Not(?ty_0), u32 = ?ty_0}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>           prove_wc goal=Not(?ty_0), assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>             may_be_remote assumptions={}, goal=Not(?ty_0), decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env=Env { variables: [?ty_0], bias: Completeness }
>               may_be_downstream_trait_ref goal=Not(?ty_0), assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                 may_be_downstream_parameter parameter=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                   DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} } from rule "type variable" in judgment "may_be_downstream_parameter"
>                   DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} }}
>                 
>                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} } from rule "may_be_downstream_trait_ref" in judgment "may_be_downstream_trait_ref"
>                 DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} }}
>               
>               DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} } from rule "may be defined downstream" in judgment "may_be_remote"
>               may_not_be_provable 
>                 DEBUG assumptions={}, data=Not(?ty_0)
>                 is_local_trait_ref goal=Not(!ty_1), assumptions={}, env=Env { variables: [!ty_1], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                   DEBUG produced Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} } from rule "local trait" in judgment "is_local_trait_ref"
>                   is_local_parameter goal=!ty_1, assumptions={}, env=Env { variables: [!ty_1], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                     prove_normalize p=!ty_1, assumptions={}, env=Env { variables: [!ty_1], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                       DEBUG output={}
>                     
>                     new judgment="prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
>                       strip_cycles failed_rules={}
>                         DEBUG cycles={}, non_cycles={}
>                         DEBUG return=({}, HasNonCycle(false))
1599,1600c1600
<                       DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
<                       DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
---
>                       DEBUG return=FailedJudgment { judgment: "prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
1601a1602,1603
>                     DEBUG rule local parameter failed at step 0 because judgment had no applicable rules: `prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/is_local.rs:LL:CC)
>                     DEBUG output={}
1603,1646c1605,1610
<                   DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential-nonvar" in judgment "prove_existential_var_eq"
<                   DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<                 
<                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential" in judgment "prove_eq"
<                 prove_normalize p=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   DEBUG output={}
<                 
<                 new judgment="prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                   strip_cycles failed_rules={}
<                     DEBUG cycles={}, non_cycles={}
<                     DEBUG return=({}, HasNonCycle(false))
<                   
<                   DEBUG return=FailedJudgment { judgment: "prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                 
<                 DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<                 DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<               
<               DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
<               prove_normalize p=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG output={}
<               
<               new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                 strip_cycles failed_rules={}
<                   DEBUG cycles={}, non_cycles={}
<                   DEBUG return=({}, HasNonCycle(false))
<                 
<                 DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<               
<               DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<               DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<               DEBUG output is different from previous iteration, re-executing until fixed point is reached
<             
<             prove_eq a=u32, b=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<               prove_eq a=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG recursive call to prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }, yielding {Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
<                 prove_existential_var_eq v=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   equate_variable x=?ty_0, p=u32, env=Env { variables: [?ty_0], bias: Completeness }
<                     DEBUG equated: constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goals={}
<                     prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                       prove goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         prove_wc_list goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                           DEBUG produced Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} } from rule "none" in judgment "prove_wc_list"
<                           DEBUG output={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
---
>                   new judgment="is_local_parameter { goal: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
>                     strip_cycles failed_rules={FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
>                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
>                         strip_cycles failed_rules={}
>                           DEBUG cycles={}, non_cycles={}
>                           DEBUG return=({}, HasNonCycle(false))
1648d1611
<                         DEBUG result_set={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
1650,1651c1613,1614
<                       DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
<                       DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
---
>                       DEBUG cycles={FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={}
>                       DEBUG return=({FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, HasNonCycle(false))
1652a1616
>                     DEBUG return=FailedJudgment { judgment: "is_local_parameter { goal: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }
1654,1659c1618,1621
<                   DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential-nonvar" in judgment "prove_existential_var_eq"
<                   DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<                 
<                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential" in judgment "prove_eq"
<                 prove_normalize p=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   DEBUG output={}
---
>                   DEBUG rule local parameter failed at step 1 because judgment `is_local_parameter { goal: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
>                     the rule "local parameter" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
>                       judgment had no applicable rules: `prove_normalize { p: !ty_1, assumptions: {}, env: Env { variables: [!ty_1], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` (crates/formality-prove/src/prove/is_local.rs:LL:CC)
>                   DEBUG output={Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} }}
1661,1664c1623,1628
<                 new judgment="prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                   strip_cycles failed_rules={}
<                     DEBUG cycles={}, non_cycles={}
<                     DEBUG return=({}, HasNonCycle(false))
---
>                 new judgment="negation_via_failure", failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} }" } }}
>                   strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} }" } }}
>                     failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} }" } }
>                     
>                     DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} }" } }}
>                     DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
1666c1630
<                   DEBUG return=FailedJudgment { judgment: "prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
---
>                   DEBUG return=FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} }" } }} }
1668,1669d1631
<                 DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<                 DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
1671,1683c1633,1636
<               DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
<               prove_normalize p=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG output={}
<               
<               new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                 strip_cycles failed_rules={}
<                   DEBUG cycles={}, non_cycles={}
<                   DEBUG return=({}, HasNonCycle(false))
<                 
<                 DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<               
<               DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<               DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
---
>               DEBUG rule may be added by upstream in a minor release failed at step 0 because judgment `negation_via_failure` failed at the following rule(s):
>                 failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
>                   found an unconditionally true solution Constraints { env: Env { variables: [!ty_1], bias: Soundness }, known_true: true, substitution: {} } (crates/formality-prove/src/prove/is_local.rs:LL:CC)
>               DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} }}
1685,1686c1638,1640
<             DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "eq" in judgment "prove_wc"
<             DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
---
>             DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} } from rule "coherence / remote impl" in judgment "prove_wc"
>             DEBUG rule trait implied bound failed at step 0 because expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
>             DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} }}
1688,1697c1642,1649
<           prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={Not(?ty_0)}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<             prove goal={Not(u32)}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<               prove_wc_list goal={Not(u32)}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 prove_wc goal=Not(u32), assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   may_be_remote assumptions={}, goal=Not(u32), decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env=Env { variables: [], bias: Completeness }
<                     may_be_downstream_trait_ref goal=Not(u32), assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                       may_be_downstream_parameter parameter=u32, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         DEBUG output={}
<                       
<                       new judgment="may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
---
>           prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {} }, goal={u32 = ?ty_0}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>             prove goal={u32 = ?ty_0}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>               prove_wc_list goal={u32 = ?ty_0}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                 prove_wc goal=u32 = ?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                   prove_eq a=u32, b=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                     prove_eq a=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                       DEBUG recursive call to prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }, yielding {}
>                       new judgment="prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
1702,1716c1654
<                         DEBUG return=FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                       
<                       DEBUG rule may_be_downstream_trait_ref failed at step 1 because judgment had no applicable rules: `may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                       DEBUG output={}
<                     
<                     new judgment="may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                       strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                           strip_cycles failed_rules={}
<                             DEBUG cycles={}, non_cycles={}
<                             DEBUG return=({}, HasNonCycle(false))
<                           
<                         
<                         DEBUG cycles={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={}
<                         DEBUG return=({FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, HasNonCycle(false))
---
>                         DEBUG return=FailedJudgment { judgment: "prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
1718,1751c1656,1664
<                       DEBUG return=FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }
<                     
<                     DEBUG rule may be defined downstream failed at step 0 because judgment `may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                       the rule "may_be_downstream_trait_ref" failed at step #1 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                         judgment had no applicable rules: `may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                     may_not_be_provable 
<                       DEBUG assumptions={}, data=Not(u32)
<                       is_local_trait_ref goal=Not(u32), assumptions={}, env=Env { variables: [], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         DEBUG produced Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} } from rule "local trait" in judgment "is_local_trait_ref"
<                         is_local_parameter goal=u32, assumptions={}, env=Env { variables: [], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                           prove_normalize p=u32, assumptions={}, env=Env { variables: [], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                             DEBUG output={}
<                           
<                           new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                             strip_cycles failed_rules={}
<                               DEBUG cycles={}, non_cycles={}
<                               DEBUG return=({}, HasNonCycle(false))
<                             
<                             DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                           
<                           DEBUG rule local parameter failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                           DEBUG rule fundamental rigid type failed at step 0 because condition evaluted to false: `is_fundamental(&decls, &name)`
<                             &decls = decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                             &name = (scalar u32) (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                           DEBUG output={}
<                         
<                         new judgment="is_local_parameter { goal: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }, FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                           strip_cycles failed_rules={FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }, FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                             failed_rule failed_rule=FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }
<                             
<                             failed_rule failed_rule=FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                               strip_cycles failed_rules={}
<                                 DEBUG cycles={}, non_cycles={}
<                                 DEBUG return=({}, HasNonCycle(false))
---
>                       DEBUG rule symmetric failed at step 0 because judgment had no applicable rules: `prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
>                       prove_existential_var_eq v=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                         equate_variable x=?ty_0, p=u32, env=Env { variables: [?ty_0], bias: Completeness }
>                           DEBUG equated: constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goals={}
>                           prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                             prove goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                               prove_wc_list goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                                 DEBUG produced Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} } from rule "none" in judgment "prove_wc_list"
>                                 DEBUG output={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
1752a1666
>                               DEBUG result_set={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
1754,1785c1668,1669
<                             DEBUG cycles={FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }}
<                             DEBUG return=({FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }}, HasNonCycle(true))
<                           
<                           DEBUG return=FailedJudgment { judgment: "is_local_parameter { goal: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }} }
<                         
<                         DEBUG rule local parameter failed at step 1 because judgment `is_local_parameter { goal: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                           the rule "fundamental rigid type" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                             condition evaluted to false: `is_fundamental(&decls, &name)`
<                               &decls = decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                               &name = (scalar u32) (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                         DEBUG output={Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }}
<                       
<                       new judgment="negation_via_failure", failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                         strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                           
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                         
<                         DEBUG return=FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }
<                       
<                     
<                     DEBUG rule may be added by upstream in a minor release failed at step 0 because judgment `negation_via_failure` failed at the following rule(s):
<                       failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                         found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} } (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                     DEBUG output={}
<                   
<                   new judgment="may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }, FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }}
<                     strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }, FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }}
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
---
>                             DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
>                             DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
1787,1788d1670
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
1789a1672,1673
>                         DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential-nonvar" in judgment "prove_existential_var_eq"
>                         DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
1791,1801c1675,1677
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                             strip_cycles failed_rules={}
<                               DEBUG cycles={}, non_cycles={}
<                               DEBUG return=({}, HasNonCycle(false))
<                             
<                           
<                           DEBUG cycles={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={}
<                           DEBUG return=({FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, HasNonCycle(false))
<                         
---
>                       DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential" in judgment "prove_eq"
>                       prove_normalize p=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                         DEBUG output={}
1803,1826c1679,1682
<                       DEBUG cycles={FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                       DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                     
<                     DEBUG return=FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }
<                   
<                   DEBUG rule coherence / remote impl failed at step 1 because judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                     the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                       judgment `negation_via_failure` failed at the following rule(s):
<                         failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                           found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} } (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
<                   DEBUG rule trait implied bound failed at step 0 because expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
<                   DEBUG output={}
<                 
<                 new judgment="prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                   strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                     failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                       strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                           strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                             failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                             
<                             DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                             DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                           
---
>                       new judgment="prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
>                         strip_cycles failed_rules={}
>                           DEBUG cycles={}, non_cycles={}
>                           DEBUG return=({}, HasNonCycle(false))
1828,1829c1684
<                         DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                         DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
---
>                         DEBUG return=FailedJudgment { judgment: "prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
1830a1686,1687
>                       DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
>                       DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
1832c1689,1691
<                     failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
---
>                     DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
>                     prove_normalize p=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                       DEBUG output={}
1834,1868c1693,1696
<                     DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                     DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
<                   
<                   DEBUG return=FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }
<                 
<                 DEBUG rule some failed at step 0 because judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                   the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                       the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                         judgment `negation_via_failure` failed at the following rule(s):
<                           failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                             found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                   the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC)
<                 DEBUG output={}
<               
<               new judgment="prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                 strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }
<                     strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                             strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                               
<                               DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                             
<                           
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                         
<                       
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
---
>                     new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
>                       strip_cycles failed_rules={}
>                         DEBUG cycles={}, non_cycles={}
>                         DEBUG return=({}, HasNonCycle(false))
1870,1871c1698
<                       DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
---
>                       DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
1872a1700,1702
>                     DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
>                     DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
>                     DEBUG output is different from previous iteration, re-executing until fixed point is reached
1874,1904c1704,1715
<                   DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   DEBUG return=({FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}, HasNonCycle(true))
<                 
<                 DEBUG return=FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }
<               
<               DEBUG result_set=FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }
<             
<             DEBUG rule prove_after failed at step 1 because judgment `prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<               the rule "some" failed at step #0 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<                 judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                   the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                       the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                         judgment `negation_via_failure` failed at the following rule(s):
<                           failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                             found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                   the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_after.rs:LL:CC)
<             DEBUG output={}
<           
<           new judgment="prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<             strip_cycles failed_rules={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<               failed_rule failed_rule=FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }
<                 strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }
<                     strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                             strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
---
>                   prove_eq a=u32, b=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                     prove_eq a=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                       DEBUG recursive call to prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }, yielding {Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
>                       DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
>                       prove_existential_var_eq v=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                         equate_variable x=?ty_0, p=u32, env=Env { variables: [?ty_0], bias: Completeness }
>                           DEBUG equated: constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goals={}
>                           prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                             prove goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                               prove_wc_list goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                                 DEBUG produced Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} } from rule "none" in judgment "prove_wc_list"
>                                 DEBUG output={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
1906,1907c1717
<                               DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
---
>                               DEBUG result_set={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
1908a1719,1720
>                             DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
>                             DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
1910,1911d1721
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
1912a1723,1724
>                         DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential-nonvar" in judgment "prove_existential_var_eq"
>                         DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
1914c1726,1728
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
---
>                       DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential" in judgment "prove_eq"
>                       prove_normalize p=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                         DEBUG output={}
1916,1966c1730,1733
<                       DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
<                     
<                   
<                   DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   DEBUG return=({FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}, HasNonCycle(true))
<                 
<               
<               DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<               DEBUG return=({FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}, HasNonCycle(true))
<             
<             DEBUG return=FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }
<           
<           DEBUG rule some failed at step 1 because judgment `prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<             the rule "prove_after" failed at step #1 (crates/formality-prove/src/prove/prove_after.rs:LL:CC) because
<               judgment `prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                 the rule "some" failed at step #0 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<                   judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                     the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                         the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                           judgment `negation_via_failure` failed at the following rule(s):
<                             failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                               found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                     the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC)
<           DEBUG output={}
<         
<         new judgment="prove_wc_list { goal: {u32 = ?ty_0, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}
<           strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}
<             failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }
<               strip_cycles failed_rules={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<                 failed_rule failed_rule=FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }
<                   strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                     failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }
<                       strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                           strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                             failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                               strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                                 failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                                 
<                                 DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                                 DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                               
<                             
<                             DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                             DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                           
<                         
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
---
>                       new judgment="prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
>                         strip_cycles failed_rules={}
>                           DEBUG cycles={}, non_cycles={}
>                           DEBUG return=({}, HasNonCycle(false))
1968,1969c1735
<                         DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                         DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
---
>                         DEBUG return=FailedJudgment { judgment: "prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
1970a1737,1738
>                       DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
>                       DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
1972,2048c1740,1742
<                     DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                     DEBUG return=({FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}, HasNonCycle(true))
<                   
<                 
<                 DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<                 DEBUG return=({FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}, HasNonCycle(true))
<               
<             
<             DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}
<             DEBUG return=({FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}, HasNonCycle(true))
<           
<           DEBUG return=FailedJudgment { judgment: "prove_wc_list { goal: {u32 = ?ty_0, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }} }
<         
<         DEBUG result_set=FailedJudgment { judgment: "prove_wc_list { goal: {u32 = ?ty_0, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }} }
<       
<       DEBUG Proved `negation_via_failure`, error = judgment `prove_wc_list { goal: {u32 = ?ty_0, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<         the rule "some" failed at step #1 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<           judgment `prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<             the rule "prove_after" failed at step #1 (crates/formality-prove/src/prove/prove_after.rs:LL:CC) because
<               judgment `prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                 the rule "some" failed at step #0 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<                   judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                     the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                         the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                           judgment `negation_via_failure` failed at the following rule(s):
<                             failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                               found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                     the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       expression evaluated to an empty collection: `decls.trait_invariants()`
<     
<   
<   DEBUG proved not ({u32 = !ty_1}, [], [!ty_1 : Not])
< 
< overlap_check impl_a=impl <ty> Foo for ^ty0_0 where ^ty0_0 : Not { }, impl_b=impl Foo for u32 { }
<   prove_not_goal env=Env { variables: [!ty_1], bias: Soundness }
<     is_definitely_not_proveable 
<       DEBUG assumptions={}, data={!ty_1 = u32, Not(!ty_1)}
<       prove goal={?ty_0 = u32, Not(?ty_0)}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<         prove_wc_list goal={?ty_0 = u32, Not(?ty_0)}, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<           prove_wc goal=?ty_0 = u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<             prove_eq a=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<               prove_eq a=u32, b=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG recursive call to prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }, yielding {}
<                 new judgment="prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                   strip_cycles failed_rules={}
<                     DEBUG cycles={}, non_cycles={}
<                     DEBUG return=({}, HasNonCycle(false))
<                   
<                   DEBUG return=FailedJudgment { judgment: "prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                 
<                 DEBUG rule symmetric failed at step 0 because judgment had no applicable rules: `prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<                 prove_normalize p=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   DEBUG output={}
<                 
<                 new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                   strip_cycles failed_rules={}
<                     DEBUG cycles={}, non_cycles={}
<                     DEBUG return=({}, HasNonCycle(false))
<                   
<                   DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                 
<                 DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<                 DEBUG output={}
<               
<               new judgment="prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("normalize-l", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("symmetric", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                 strip_cycles failed_rules={FailedRule { rule_name_index: Some(("normalize-l", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("symmetric", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                   failed_rule failed_rule=FailedRule { rule_name_index: Some(("normalize-l", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                     strip_cycles failed_rules={}
<                       DEBUG cycles={}, non_cycles={}
<                       DEBUG return=({}, HasNonCycle(false))
<                     
<                   
<                   failed_rule failed_rule=FailedRule { rule_name_index: Some(("symmetric", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                     strip_cycles failed_rules={}
<                       DEBUG cycles={}, non_cycles={}
<                       DEBUG return=({}, HasNonCycle(false))
---
>                     DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
>                     prove_normalize p=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                       DEBUG output={}
2050,2068c1744,1747
<                   
<                   DEBUG cycles={FailedRule { rule_name_index: Some(("normalize-l", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("symmetric", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={}
<                   DEBUG return=({FailedRule { rule_name_index: Some(("normalize-l", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("symmetric", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, HasNonCycle(false))
<                 
<                 DEBUG return=FailedJudgment { judgment: "prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("normalize-l", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("symmetric", 0)), file: "crates/formality-prove/src/prove/prove_eq.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }
<               
<               DEBUG rule symmetric failed at step 0 because judgment `prove_eq { a: u32, b: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                 the rule "normalize-l" failed at step #0 (crates/formality-prove/src/prove/prove_eq.rs:LL:CC) because
<                   judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`
<                 the rule "symmetric" failed at step #0 (crates/formality-prove/src/prove/prove_eq.rs:LL:CC) because
<                   judgment had no applicable rules: `prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<               prove_existential_var_eq v=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 equate_variable x=?ty_0, p=u32, env=Env { variables: [?ty_0], bias: Completeness }
<                   DEBUG equated: constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goals={}
<                   prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                     prove goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                       prove_wc_list goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         DEBUG produced Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} } from rule "none" in judgment "prove_wc_list"
<                         DEBUG output={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
---
>                     new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
>                       strip_cycles failed_rules={}
>                         DEBUG cycles={}, non_cycles={}
>                         DEBUG return=({}, HasNonCycle(false))
2070c1749
<                       DEBUG result_set={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
---
>                       DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
2072c1751
<                     DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
---
>                     DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
2074a1754,1755
>                   DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "eq" in judgment "prove_wc"
>                   DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
2076,2121c1757,1761
<                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential-nonvar" in judgment "prove_existential_var_eq"
<                 DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<               
<               DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential" in judgment "prove_eq"
<               prove_normalize p=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG output={}
<               
<               new judgment="prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                 strip_cycles failed_rules={}
<                   DEBUG cycles={}, non_cycles={}
<                   DEBUG return=({}, HasNonCycle(false))
<                 
<                 DEBUG return=FailedJudgment { judgment: "prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<               
<               DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<               DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<               DEBUG output is different from previous iteration, re-executing until fixed point is reached
<             
<             prove_eq a=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<               prove_eq a=u32, b=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG recursive call to prove_eq { a: ?ty_0, b: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }, yielding {Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
<                 prove_normalize p=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   DEBUG output={}
<                 
<                 new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                   strip_cycles failed_rules={}
<                     DEBUG cycles={}, non_cycles={}
<                     DEBUG return=({}, HasNonCycle(false))
<                   
<                   DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                 
<                 DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<                 DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
<               
<               DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "symmetric" in judgment "prove_eq"
<               prove_existential_var_eq v=?ty_0, b=u32, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 equate_variable x=?ty_0, p=u32, env=Env { variables: [?ty_0], bias: Completeness }
<                   DEBUG equated: constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goals={}
<                   prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                     prove goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                       prove_wc_list goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         DEBUG produced Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} } from rule "none" in judgment "prove_wc_list"
<                         DEBUG output={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
<                       
<                       DEBUG result_set={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
---
>                 prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                   prove goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                     prove_wc_list goal={}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>                       DEBUG produced Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} } from rule "none" in judgment "prove_wc_list"
>                       DEBUG output={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
2123,2124c1763
<                     DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
<                     DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
---
>                     DEBUG result_set={Constraints { env: Env { variables: [], bias: Completeness }, known_true: true, substitution: {} }}
2125a1765,1766
>                   DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
>                   DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
2127c1768
<                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential-nonvar" in judgment "prove_existential_var_eq"
---
>                 DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "some" in judgment "prove_wc_list"
2130,2142c1771
<               DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "existential" in judgment "prove_eq"
<               prove_normalize p=?ty_0, assumptions={}, env=Env { variables: [?ty_0], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 DEBUG output={}
<               
<               new judgment="prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                 strip_cycles failed_rules={}
<                   DEBUG cycles={}, non_cycles={}
<                   DEBUG return=({}, HasNonCycle(false))
<                 
<                 DEBUG return=FailedJudgment { judgment: "prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<               
<               DEBUG rule normalize-l failed at step 0 because judgment had no applicable rules: `prove_normalize { p: ?ty_0, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_eq.rs:LL:CC)
<               DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
---
>               DEBUG result_set={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
2144c1773
<             DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "eq" in judgment "prove_wc"
---
>             DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "prove_after" in judgment "prove_after"
2147,2338c1776,1817
<           prove_after constraints=Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal={Not(?ty_0)}, assumptions={}, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<             prove goal={Not(u32)}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<               prove_wc_list goal={Not(u32)}, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                 prove_wc goal=Not(u32), assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                   may_be_remote assumptions={}, goal=Not(u32), decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env=Env { variables: [], bias: Completeness }
<                     may_be_downstream_trait_ref goal=Not(u32), assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                       may_be_downstream_parameter parameter=u32, assumptions={}, env=Env { variables: [], bias: Completeness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         DEBUG output={}
<                       
<                       new judgment="may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                         strip_cycles failed_rules={}
<                           DEBUG cycles={}, non_cycles={}
<                           DEBUG return=({}, HasNonCycle(false))
<                         
<                         DEBUG return=FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                       
<                       DEBUG rule may_be_downstream_trait_ref failed at step 1 because judgment had no applicable rules: `may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                       DEBUG output={}
<                     
<                     new judgment="may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                       strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                           strip_cycles failed_rules={}
<                             DEBUG cycles={}, non_cycles={}
<                             DEBUG return=({}, HasNonCycle(false))
<                           
<                         
<                         DEBUG cycles={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={}
<                         DEBUG return=({FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, HasNonCycle(false))
<                       
<                       DEBUG return=FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }
<                     
<                     DEBUG rule may be defined downstream failed at step 0 because judgment `may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                       the rule "may_be_downstream_trait_ref" failed at step #1 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                         judgment had no applicable rules: `may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                     may_not_be_provable 
<                       DEBUG assumptions={}, data=Not(u32)
<                       is_local_trait_ref goal=Not(u32), assumptions={}, env=Env { variables: [], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                         DEBUG produced Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} } from rule "local trait" in judgment "is_local_trait_ref"
<                         is_local_parameter goal=u32, assumptions={}, env=Env { variables: [], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                           prove_normalize p=u32, assumptions={}, env=Env { variables: [], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                             DEBUG output={}
<                           
<                           new judgment="prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
<                             strip_cycles failed_rules={}
<                               DEBUG cycles={}, non_cycles={}
<                               DEBUG return=({}, HasNonCycle(false))
<                             
<                             DEBUG return=FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
<                           
<                           DEBUG rule local parameter failed at step 0 because judgment had no applicable rules: `prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                           DEBUG rule fundamental rigid type failed at step 0 because condition evaluted to false: `is_fundamental(&decls, &name)`
<                             &decls = decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                             &name = (scalar u32) (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                           DEBUG output={}
<                         
<                         new judgment="is_local_parameter { goal: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }, FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                           strip_cycles failed_rules={FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }, FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                             failed_rule failed_rule=FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }
<                             
<                             failed_rule failed_rule=FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                               strip_cycles failed_rules={}
<                                 DEBUG cycles={}, non_cycles={}
<                                 DEBUG return=({}, HasNonCycle(false))
<                               
<                             
<                             DEBUG cycles={FailedRule { rule_name_index: Some(("local parameter", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_normalize { p: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }}
<                             DEBUG return=({FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }}, HasNonCycle(true))
<                           
<                           DEBUG return=FailedJudgment { judgment: "is_local_parameter { goal: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("fundamental rigid type", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: IfFalse { expr: "is_fundamental(&decls, &name)", args: [("&decls", "decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})"), ("&name", "(scalar u32)")] } }} }
<                         
<                         DEBUG rule local parameter failed at step 1 because judgment `is_local_parameter { goal: u32, assumptions: {}, env: Env { variables: [], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                           the rule "fundamental rigid type" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                             condition evaluted to false: `is_fundamental(&decls, &name)`
<                               &decls = decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
<                               &name = (scalar u32) (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                         DEBUG output={Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }}
<                       
<                       new judgment="negation_via_failure", failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                         strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                           
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                         
<                         DEBUG return=FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }
<                       
<                     
<                     DEBUG rule may be added by upstream in a minor release failed at step 0 because judgment `negation_via_failure` failed at the following rule(s):
<                       failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                         found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} } (crates/formality-prove/src/prove/is_local.rs:LL:CC)
<                     DEBUG output={}
<                   
<                   new judgment="may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }, FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }}
<                     strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }, FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }}
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                           
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                           DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                         
<                       
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
<                             strip_cycles failed_rules={}
<                               DEBUG cycles={}, non_cycles={}
<                               DEBUG return=({}, HasNonCycle(false))
<                             
<                           
<                           DEBUG cycles={FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={}
<                           DEBUG return=({FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, HasNonCycle(false))
<                         
<                       
<                       DEBUG cycles={FailedRule { rule_name_index: Some(("may be defined downstream", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_trait_ref { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("may_be_downstream_trait_ref", 1)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_downstream_parameter { parameter: u32, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }} }) }}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                       DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                     
<                     DEBUG return=FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }
<                   
<                   DEBUG rule coherence / remote impl failed at step 1 because judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                     the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                       judgment `negation_via_failure` failed at the following rule(s):
<                         failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                           found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} } (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
<                   DEBUG rule trait implied bound failed at step 0 because expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
<                   DEBUG output={}
<                 
<                 new judgment="prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                   strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                     failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                       strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                           strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                             failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                             
<                             DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                             DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                           
<                         
<                         DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                         DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                       
<                     
<                     failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
<                     
<                     DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                     DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
<                   
<                   DEBUG return=FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }
<                 
<                 DEBUG rule some failed at step 0 because judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                   the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                       the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                         judgment `negation_via_failure` failed at the following rule(s):
<                           failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                             found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                   the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC)
<                 DEBUG output={}
<               
<               new judgment="prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                 strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }
<                     strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                             strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                               
<                               DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                             
<                           
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                         
<                       
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
<                       
<                       DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
<                     
<                   
<                   DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   DEBUG return=({FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}, HasNonCycle(true))
<                 
<                 DEBUG return=FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }
<               
<               DEBUG result_set=FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }
---
>           DEBUG produced Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} } from rule "some" in judgment "prove_wc_list"
>           DEBUG output={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
>         
>         DEBUG result_set={Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }}
>       
>       DEBUG ambiguous `negation_via_failure`, solutions: {Constraints { env: Env { variables: [?ty_1], bias: Completeness }, known_true: true, substitution: {?ty_1 => u32} }}
>     
>   
>   prove goal={! Not(!ty_0)}, assumptions={Not(!ty_0), u32 = !ty_0}, env=Env { variables: [!ty_0], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>     prove_wc_list goal={! Not(!ty_0)}, assumptions={Not(!ty_0), u32 = !ty_0}, env=Env { variables: [!ty_0], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>       prove_wc goal=! Not(!ty_0), assumptions={Not(!ty_0), u32 = !ty_0}, env=Env { variables: [!ty_0], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>         prove_via goal=! Not(!ty_0), via=Not(!ty_0), assumptions={Not(!ty_0), u32 = !ty_0}, env=Env { variables: [!ty_0], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>           DEBUG output={}
>         
>         new judgment="prove_via { goal: ! Not(!ty_0), via: Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
>           strip_cycles failed_rules={}
>             DEBUG cycles={}, non_cycles={}
>             DEBUG return=({}, HasNonCycle(false))
>           
>           DEBUG return=FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
>         
>         DEBUG rule assumption failed at step 1 because judgment had no applicable rules: `prove_via { goal: ! Not(!ty_0), via: Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
>         prove_via goal=! Not(!ty_0), via=u32 = !ty_0, assumptions={Not(!ty_0), u32 = !ty_0}, env=Env { variables: [!ty_0], bias: Soundness }, decls=decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {})
>           DEBUG output={}
>         
>         new judgment="prove_via { goal: ! Not(!ty_0), via: u32 = !ty_0, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={}
>           strip_cycles failed_rules={}
>             DEBUG cycles={}, non_cycles={}
>             DEBUG return=({}, HasNonCycle(false))
>           
>           DEBUG return=FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: u32 = !ty_0, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }
>         
>         DEBUG rule assumption failed at step 1 because judgment had no applicable rules: `prove_via { goal: ! Not(!ty_0), via: u32 = !ty_0, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }`  (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
>         DEBUG rule negative impl failed at step 0 because expression evaluated to an empty collection: `decls.neg_impl_decls(&trait_ref.trait_id)` (crates/formality-prove/src/prove/prove_wc.rs:LL:CC)
>         DEBUG output={}
>       
>       new judgment="prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: u32 = !ty_0, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }}
>         strip_cycles failed_rules={FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: u32 = !ty_0, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }}
>           failed_rule failed_rule=FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
>             strip_cycles failed_rules={}
>               DEBUG cycles={}, non_cycles={}
>               DEBUG return=({}, HasNonCycle(false))
2340,2351d1818
<             DEBUG rule prove_after failed at step 1 because judgment `prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<               the rule "some" failed at step #0 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<                 judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                   the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                       the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                         judgment `negation_via_failure` failed at the following rule(s):
<                           failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                             found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                   the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                     expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_after.rs:LL:CC)
<             DEBUG output={}
2353,2384c1820,1823
<           new judgment="prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<             strip_cycles failed_rules={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<               failed_rule failed_rule=FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }
<                 strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }
<                     strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                         strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                             strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                               
<                               DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                               DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                             
<                           
<                           DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                           DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                         
<                       
<                       failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
<                       
<                       DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                       DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
<                     
<                   
<                   DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                   DEBUG return=({FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}, HasNonCycle(true))
<                 
<               
<               DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<               DEBUG return=({FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}, HasNonCycle(true))
---
>           failed_rule failed_rule=FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: u32 = !ty_0, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }
>             strip_cycles failed_rules={}
>               DEBUG cycles={}, non_cycles={}
>               DEBUG return=({}, HasNonCycle(false))
2386d1824
<             DEBUG return=FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }
2388,2401c1826,1829
<           DEBUG rule some failed at step 1 because judgment `prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<             the rule "prove_after" failed at step #1 (crates/formality-prove/src/prove/prove_after.rs:LL:CC) because
<               judgment `prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                 the rule "some" failed at step #0 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<                   judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                     the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                         the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                           judgment `negation_via_failure` failed at the following rule(s):
<                             failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                               found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                     the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       expression evaluated to an empty collection: `decls.trait_invariants()` (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC)
<           DEBUG output={}
---
>           failed_rule failed_rule=FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }
>           
>           DEBUG cycles={FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }, FailedRule { rule_name_index: Some(("assumption", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_via { goal: ! Not(!ty_0), via: u32 = !ty_0, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {} }) }}, non_cycles={FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }}
>           DEBUG return=({FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }}, HasNonCycle(true))
2403,2437c1831,1842
<         new judgment="prove_wc_list { goal: {?ty_0 = u32, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}
<           strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}
<             failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }
<               strip_cycles failed_rules={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<                 failed_rule failed_rule=FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }
<                   strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                     failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }
<                       strip_cycles failed_rules={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }
<                           strip_cycles failed_rules={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                             failed_rule failed_rule=FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }
<                               strip_cycles failed_rules={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                                 failed_rule failed_rule=FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }
<                                 
<                                 DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}
<                                 DEBUG return=({FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }}, HasNonCycle(true))
<                               
<                             
<                             DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}
<                             DEBUG return=({FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }}, HasNonCycle(true))
<                           
<                         
<                         failed_rule failed_rule=FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }
<                         
<                         DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}
<                         DEBUG return=({FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }}, HasNonCycle(true))
<                       
<                     
<                     DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}
<                     DEBUG return=({FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }}, HasNonCycle(true))
<                   
<                 
<                 DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}
<                 DEBUG return=({FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }}, HasNonCycle(true))
<               
---
>         DEBUG return=FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }
>       
>       DEBUG rule some failed at step 0 because judgment `prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
>         the rule "negative impl" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
>           expression evaluated to an empty collection: `decls.neg_impl_decls(&trait_ref.trait_id)` (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC)
>       DEBUG output={}
>     
>     new judgment="prove_wc_list { goal: {! Not(!ty_0)}, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }) }}
>       strip_cycles failed_rules={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }) }}
>         failed_rule failed_rule=FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }) }
>           strip_cycles failed_rules={FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }}
>             failed_rule failed_rule=FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }
2439,2440c1844,1845
<             DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}
<             DEBUG return=({FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }}, HasNonCycle(true))
---
>             DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }}
>             DEBUG return=({FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }}, HasNonCycle(true))
2442d1846
<           DEBUG return=FailedJudgment { judgment: "prove_wc_list { goal: {?ty_0 = u32, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }} }
2444c1848,1849
<         DEBUG result_set=FailedJudgment { judgment: "prove_wc_list { goal: {?ty_0 = u32, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 1)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("prove_after", 1)), file: "crates/formality-prove/src/prove/prove_after.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("coherence / remote impl", 1)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }", failed_rules: {FailedRule { rule_name_index: Some(("may be added by upstream in a minor release", 0)), file: "crates/formality-prove/src/prove/is_local.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "negation_via_failure", failed_rules: {FailedRule { rule_name_index: None, file: "crates/formality-prove/src/prove/negation.rs", line: LL, column: CC, cause: Inapplicable { reason: "found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }" } }} }) }} }) }, FailedRule { rule_name_index: Some(("trait implied bound", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.trait_invariants()" } }} }) }} }) }} }) }} }
---
>         DEBUG cycles={}, non_cycles={FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }) }}
>         DEBUG return=({FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }) }}, HasNonCycle(true))
2446,2460c1851
<       DEBUG Proved `negation_via_failure`, error = judgment `prove_wc_list { goal: {?ty_0 = u32, Not(?ty_0)}, assumptions: {}, env: Env { variables: [?ty_0], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<         the rule "some" failed at step #1 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<           judgment `prove_after { constraints: Constraints { env: Env { variables: [?ty_0], bias: Completeness }, known_true: true, substitution: {?ty_0 => u32} }, goal: {Not(?ty_0)}, assumptions: {}, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<             the rule "prove_after" failed at step #1 (crates/formality-prove/src/prove/prove_after.rs:LL:CC) because
<               judgment `prove_wc_list { goal: {Not(u32)}, assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                 the rule "some" failed at step #0 (crates/formality-prove/src/prove/prove_wc_list.rs:LL:CC) because
<                   judgment `prove_wc { goal: Not(u32), assumptions: {}, env: Env { variables: [], bias: Completeness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }` failed at the following rule(s):
<                     the rule "coherence / remote impl" failed at step #1 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       judgment `may_be_remote { assumptions: {}, goal: Not(u32), decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}), env: Env { variables: [], bias: Completeness } }` failed at the following rule(s):
<                         the rule "may be added by upstream in a minor release" failed at step #0 (crates/formality-prove/src/prove/is_local.rs:LL:CC) because
<                           judgment `negation_via_failure` failed at the following rule(s):
<                             failed at (crates/formality-prove/src/prove/negation.rs:LL:CC) because
<                               found an unconditionally true solution Constraints { env: Env { variables: [], bias: Soundness }, known_true: true, substitution: {} }
<                     the rule "trait implied bound" failed at step #0 (crates/formality-prove/src/prove/prove_wc.rs:LL:CC) because
<                       expression evaluated to an empty collection: `decls.trait_invariants()`
---
>       DEBUG return=FailedJudgment { judgment: "prove_wc_list { goal: {! Not(!ty_0)}, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }) }} }
2461a1853
>     DEBUG result_set=FailedJudgment { judgment: "prove_wc_list { goal: {! Not(!ty_0)}, assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("some", 0)), file: "crates/formality-prove/src/prove/prove_wc_list.rs", line: LL, column: CC, cause: FailedJudgment(FailedJudgment { judgment: "prove_wc { goal: ! Not(!ty_0), assumptions: {Not(!ty_0), u32 = !ty_0}, env: Env { variables: [!ty_0], bias: Soundness }, decls: decls(222, [trait Foo <ty> , trait Not <ty> ], [impl Foo(u32), impl <ty> Foo(^ty0_0) where {Not(^ty0_0)}], [], [], [], [], {Foo, Not}, {}) }", failed_rules: {FailedRule { rule_name_index: Some(("negative impl", 0)), file: "crates/formality-prove/src/prove/prove_wc.rs", line: LL, column: CC, cause: EmptyCollection { expr: "decls.neg_impl_decls(&trait_ref.trait_id)" } }} }) }} }
2463,2487d1854
<   DEBUG proved not ({!ty_1 = u32}, [!ty_1 : Not], [])
< 
< test test::coherence_overlap::u32_T_where_T_Not_impls ... ok
< 
< test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 45 filtered out; finished in 0.04s
< 
< 
< running 0 tests
< 
< test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
< 
< 
< running 0 tests
< 
< test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
< 
< 
< running 0 tests
< 
< test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
< 
< 
< running 0 tests
< 
< test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out; finished in 0.00s
2488a1856
> test test::coherence_overlap::u32_T_where_T_Not_impls ... FAILED
2490c1858
< running 0 tests
---
> failures:
2492c1860,1865
< test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 21 filtered out; finished in 0.00s
---
> ---- test::coherence_overlap::u32_T_where_T_Not_impls stdout ----
> thread 'test::coherence_overlap::u32_T_where_T_Not_impls' panicked at src/test/coherence_overlap.rs:LL:CC:
> expected `Ok`, got `Err`: impls may overlap:
> impl Foo for u32 { }
> impl <ty> Foo for ^ty0_0 where ^ty0_0 : Not { }
> note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
2495c1868,1869
< running 0 tests
---
> failures:
>     test::coherence_overlap::u32_T_where_T_Not_impls
2497c1871
< test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out; finished in 0.00s
---
> test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 45 filtered out; finished in 0.11s
